import {
  require_cssesc
} from "./chunk-OD322OVE.js";
import {
  __publicField,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/astro/dist/core/errors/errors-data.js
var MissingLocale = {
  name: "MissingLocaleError",
  title: "The provided locale does not exist.",
  message: (locale) => `The locale/path \`${locale}\` does not exist in the configured \`i18n.locales\`.`
};
var IncorrectStrategyForI18n = {
  name: "IncorrectStrategyForI18n",
  title: "You can't use the current function with the current strategy",
  message: (functionName) => `The function \`${functionName}\` can only be used when the \`i18n.routing.strategy\` is set to \`"manual"\`.`
};
var i18nNoLocaleFoundInPath = {
  name: "i18nNoLocaleFoundInPath",
  title: "The path doesn't contain any locale",
  message: "You tried to use an i18n utility on a path that doesn't contain any locale. You can use `pathHasLocale` first to determine if the path has a locale."
};

// node_modules/astro/dist/core/errors/utils.js
function normalizeLF(code) {
  return code.replace(/\r\n|\r(?!\n)|\n/g, "\n");
}

// node_modules/astro/dist/core/errors/printer.js
function codeFrame(src, loc) {
  if (!loc || loc.line === void 0 || loc.column === void 0) {
    return "";
  }
  const lines = normalizeLF(src).split("\n").map((ln) => ln.replace(/\t/g, "  "));
  const visibleLines = [];
  for (let n = -2; n <= 2; n++) {
    if (lines[loc.line + n]) visibleLines.push(loc.line + n);
  }
  let gutterWidth = 0;
  for (const lineNo of visibleLines) {
    let w = `> ${lineNo}`;
    if (w.length > gutterWidth) gutterWidth = w.length;
  }
  let output = "";
  for (const lineNo of visibleLines) {
    const isFocusedLine = lineNo === loc.line - 1;
    output += isFocusedLine ? "> " : "  ";
    output += `${lineNo + 1} | ${lines[lineNo]}
`;
    if (isFocusedLine)
      output += `${Array.from({ length: gutterWidth }).join(" ")}  | ${Array.from({
        length: loc.column
      }).join(" ")}^
`;
  }
  return output;
}

// node_modules/astro/dist/core/errors/errors.js
var AstroError = class extends Error {
  constructor(props, options) {
    const { name, title, message, stack, location, hint, frame } = props;
    super(message, options);
    __publicField(this, "loc");
    __publicField(this, "title");
    __publicField(this, "hint");
    __publicField(this, "frame");
    __publicField(this, "type", "AstroError");
    this.title = title;
    this.name = name;
    if (message) this.message = message;
    this.stack = stack ? stack : this.stack;
    this.loc = location;
    this.hint = hint;
    this.frame = frame;
  }
  setLocation(location) {
    this.loc = location;
  }
  setName(name) {
    this.name = name;
  }
  setMessage(message) {
    this.message = message;
  }
  setHint(hint) {
    this.hint = hint;
  }
  setFrame(source, location) {
    this.frame = codeFrame(source, location);
  }
  static is(err) {
    return err.type === "AstroError";
  }
};

// node_modules/@astrojs/internal-helpers/dist/path.js
function appendForwardSlash(path) {
  return path.endsWith("/") ? path : path + "/";
}
function removeTrailingForwardSlash(path) {
  return path.endsWith("/") ? path.slice(0, path.length - 1) : path;
}
function removeLeadingForwardSlash(path) {
  return path.startsWith("/") ? path.substring(1) : path;
}
function trimSlashes(path) {
  return path.replace(/^\/|\/$/g, "");
}
function isString(path) {
  return typeof path === "string" || path instanceof String;
}
function joinPaths(...paths) {
  return paths.filter(isString).map((path, i) => {
    if (i === 0) {
      return removeTrailingForwardSlash(path);
    } else if (i === paths.length - 1) {
      return removeLeadingForwardSlash(path);
    } else {
      return trimSlashes(path);
    }
  }).join("/");
}

// node_modules/astro/dist/core/build/util.js
function shouldAppendForwardSlash(trailingSlash2, buildFormat) {
  switch (trailingSlash2) {
    case "always":
      return true;
    case "never":
      return false;
    case "ignore": {
      switch (buildFormat) {
        case "directory":
          return true;
        case "preserve":
        case "file":
          return false;
      }
    }
  }
}

// node_modules/astro/dist/core/constants.js
var REROUTE_DIRECTIVE_HEADER = "X-Astro-Reroute";
var ROUTE_TYPE_HEADER = "X-Astro-Route-Type";
var clientAddressSymbol = Symbol.for("astro.clientAddress");
var clientLocalsSymbol = Symbol.for("astro.locals");
var originPathnameSymbol = Symbol.for("astro.originPathname");
var responseSentSymbol = Symbol.for("astro.responseSent");

// node_modules/kleur/colors.mjs
var FORCE_COLOR;
var NODE_DISABLE_COLORS;
var NO_COLOR;
var TERM;
var isTTY = true;
if (typeof process !== "undefined") {
  ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
  isTTY = process.stdout && process.stdout.isTTY;
}
var $ = {
  enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== "dumb" && (FORCE_COLOR != null && FORCE_COLOR !== "0" || isTTY)
};
function init(x, y) {
  let rgx = new RegExp(`\\x1b\\[${y}m`, "g");
  let open = `\x1B[${x}m`, close = `\x1B[${y}m`;
  return function(txt) {
    if (!$.enabled || txt == null) return txt;
    return open + (!!~("" + txt).indexOf(close) ? txt.replace(rgx, close + open) : txt) + close;
  };
}
var reset = init(0, 0);
var bold = init(1, 22);
var dim = init(2, 22);
var italic = init(3, 23);
var underline = init(4, 24);
var inverse = init(7, 27);
var hidden = init(8, 28);
var strikethrough = init(9, 29);
var black = init(30, 39);
var red = init(31, 39);
var green = init(32, 39);
var yellow = init(33, 39);
var blue = init(34, 39);
var magenta = init(35, 39);
var cyan = init(36, 39);
var white = init(37, 39);
var gray = init(90, 39);
var grey = init(90, 39);
var bgBlack = init(40, 49);
var bgRed = init(41, 49);
var bgGreen = init(42, 49);
var bgYellow = init(43, 49);
var bgBlue = init(44, 49);
var bgMagenta = init(45, 49);
var bgCyan = init(46, 49);
var bgWhite = init(47, 49);

// node_modules/html-escaper/esm/index.js
var { replace } = "";
var ca = /[&<>'"]/g;
var esca = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  "'": "&#39;",
  '"': "&quot;"
};
var pe = (m) => esca[m];
var escape = (es) => replace.call(es, ca, pe);

// node_modules/astro/dist/runtime/server/util.js
function isPromise(value) {
  return !!value && typeof value === "object" && "then" in value && typeof value.then === "function";
}

// node_modules/astro/dist/runtime/server/escape.js
var escapeHTML = escape;
var HTMLBytes = class extends Uint8Array {
};
Object.defineProperty(HTMLBytes.prototype, Symbol.toStringTag, {
  get() {
    return "HTMLBytes";
  }
});
var HTMLString = class extends String {
  get [Symbol.toStringTag]() {
    return "HTMLString";
  }
};
var markHTMLString = (value) => {
  if (value instanceof HTMLString) {
    return value;
  }
  if (typeof value === "string") {
    return new HTMLString(value);
  }
  return value;
};
function isHTMLString(value) {
  return Object.prototype.toString.call(value) === "[object HTMLString]";
}

// node_modules/astro/dist/jsx-runtime/index.js
var Empty = Symbol("empty");

// node_modules/astro/dist/runtime/server/render/instruction.js
var RenderInstructionSymbol = Symbol.for("astro:render");

// node_modules/astro/dist/runtime/server/hydration.js
var transitionDirectivesToCopyOnIsland = Object.freeze([
  "data-astro-transition-scope",
  "data-astro-transition-persist",
  "data-astro-transition-persist-props"
]);

// node_modules/astro/dist/runtime/server/shorthash.js
var dictionary = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY";
var binary = dictionary.length;

// node_modules/astro/dist/runtime/server/render/astro/head-and-content.js
var headAndContentSym = Symbol.for("astro.headAndContent");
function isHeadAndContent(obj) {
  return typeof obj === "object" && obj !== null && !!obj[headAndContentSym];
}

// node_modules/astro/dist/runtime/server/render/util.js
var noop = () => {
};
var BufferedRenderer = class {
  constructor(destination, renderFunction) {
    __publicField(this, "chunks", []);
    __publicField(this, "renderPromise");
    __publicField(this, "destination");
    /**
     * Determines whether buffer has been flushed
     * to the final destination.
     */
    __publicField(this, "flushed", false);
    this.destination = destination;
    this.renderPromise = renderFunction(this);
    if (isPromise(this.renderPromise)) {
      Promise.resolve(this.renderPromise).catch(noop);
    }
  }
  write(chunk) {
    if (this.flushed) {
      this.destination.write(chunk);
    } else {
      this.chunks.push(chunk);
    }
  }
  flush() {
    if (this.flushed) {
      throw new Error("The render buffer has already been flushed.");
    }
    this.flushed = true;
    for (const chunk of this.chunks) {
      this.destination.write(chunk);
    }
    return this.renderPromise;
  }
};
function createBufferedRenderer(destination, renderFunction) {
  return new BufferedRenderer(destination, renderFunction);
}
var isNode = typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]";

// node_modules/astro/dist/runtime/server/render/astro/render-template.js
var renderTemplateResultSym = Symbol.for("astro.renderTemplateResult");
var _a;
_a = renderTemplateResultSym;
var RenderTemplateResult = class {
  constructor(htmlParts, expressions) {
    __publicField(this, _a, true);
    __publicField(this, "htmlParts");
    __publicField(this, "expressions");
    __publicField(this, "error");
    this.htmlParts = htmlParts;
    this.error = void 0;
    this.expressions = expressions.map((expression) => {
      if (isPromise(expression)) {
        return Promise.resolve(expression).catch((err) => {
          if (!this.error) {
            this.error = err;
            throw err;
          }
        });
      }
      return expression;
    });
  }
  render(destination) {
    const flushers = this.expressions.map((exp) => {
      return createBufferedRenderer(destination, (bufferDestination) => {
        if (exp || exp === 0) {
          return renderChild(bufferDestination, exp);
        }
      });
    });
    let i = 0;
    const iterate = () => {
      while (i < this.htmlParts.length) {
        const html = this.htmlParts[i];
        const flusher = flushers[i];
        i++;
        if (html) {
          destination.write(markHTMLString(html));
        }
        if (flusher) {
          const result = flusher.flush();
          if (isPromise(result)) {
            return result.then(iterate);
          }
        }
      }
    };
    return iterate();
  }
};
function isRenderTemplateResult(obj) {
  return typeof obj === "object" && obj !== null && !!obj[renderTemplateResultSym];
}

// node_modules/astro/dist/runtime/server/render/slot.js
var slotString = Symbol.for("astro:slot-string");
var _a2, _b;
var SlotString = class extends (_b = HTMLString, _a2 = slotString, _b) {
  constructor(content, instructions) {
    super(content);
    __publicField(this, "instructions");
    __publicField(this, _a2);
    this.instructions = instructions;
    this[slotString] = true;
  }
};

// node_modules/astro/dist/runtime/server/render/common.js
var Fragment = Symbol.for("astro:fragment");
var Renderer = Symbol.for("astro:renderer");
var encoder = new TextEncoder();
var decoder = new TextDecoder();
function isRenderInstance(obj) {
  return !!obj && typeof obj === "object" && "render" in obj && typeof obj.render === "function";
}

// node_modules/astro/dist/runtime/server/render/any.js
function renderChild(destination, child) {
  if (isPromise(child)) {
    return child.then((x) => renderChild(destination, x));
  }
  if (child instanceof SlotString) {
    destination.write(child);
    return;
  }
  if (isHTMLString(child)) {
    destination.write(child);
    return;
  }
  if (Array.isArray(child)) {
    return renderArray(destination, child);
  }
  if (typeof child === "function") {
    return renderChild(destination, child());
  }
  if (!child && child !== 0) {
    return;
  }
  if (typeof child === "string") {
    destination.write(markHTMLString(escapeHTML(child)));
    return;
  }
  if (isRenderInstance(child)) {
    return child.render(destination);
  }
  if (isRenderTemplateResult(child)) {
    return child.render(destination);
  }
  if (isAstroComponentInstance(child)) {
    return child.render(destination);
  }
  if (ArrayBuffer.isView(child)) {
    destination.write(child);
    return;
  }
  if (typeof child === "object" && (Symbol.asyncIterator in child || Symbol.iterator in child)) {
    if (Symbol.asyncIterator in child) {
      return renderAsyncIterable(destination, child);
    }
    return renderIterable(destination, child);
  }
  destination.write(child);
}
function renderArray(destination, children) {
  const flushers = children.map((c) => {
    return createBufferedRenderer(destination, (bufferDestination) => {
      return renderChild(bufferDestination, c);
    });
  });
  const iterator = flushers[Symbol.iterator]();
  const iterate = () => {
    for (; ; ) {
      const { value: flusher, done } = iterator.next();
      if (done) {
        break;
      }
      const result = flusher.flush();
      if (isPromise(result)) {
        return result.then(iterate);
      }
    }
  };
  return iterate();
}
function renderIterable(destination, children) {
  const iterator = children[Symbol.iterator]();
  const iterate = () => {
    for (; ; ) {
      const { value, done } = iterator.next();
      if (done) {
        break;
      }
      const result = renderChild(destination, value);
      if (isPromise(result)) {
        return result.then(iterate);
      }
    }
  };
  return iterate();
}
async function renderAsyncIterable(destination, children) {
  for await (const value of children) {
    await renderChild(destination, value);
  }
}

// node_modules/astro/dist/runtime/server/render/astro/instance.js
var astroComponentInstanceSym = Symbol.for("astro.componentInstance");
var _a3;
_a3 = astroComponentInstanceSym;
var AstroComponentInstance = class {
  constructor(result, props, slots, factory) {
    __publicField(this, _a3, true);
    __publicField(this, "result");
    __publicField(this, "props");
    __publicField(this, "slotValues");
    __publicField(this, "factory");
    __publicField(this, "returnValue");
    this.result = result;
    this.props = props;
    this.factory = factory;
    this.slotValues = {};
    for (const name in slots) {
      let didRender = false;
      let value = slots[name](result);
      this.slotValues[name] = () => {
        if (!didRender) {
          didRender = true;
          return value;
        }
        return slots[name](result);
      };
    }
  }
  init(result) {
    if (this.returnValue !== void 0) {
      return this.returnValue;
    }
    this.returnValue = this.factory(result, this.props, this.slotValues);
    if (isPromise(this.returnValue)) {
      this.returnValue.then((resolved) => {
        this.returnValue = resolved;
      }).catch(() => {
      });
    }
    return this.returnValue;
  }
  render(destination) {
    const returnValue = this.init(this.result);
    if (isPromise(returnValue)) {
      return returnValue.then((x) => this.renderImpl(destination, x));
    }
    return this.renderImpl(destination, returnValue);
  }
  renderImpl(destination, returnValue) {
    if (isHeadAndContent(returnValue)) {
      return returnValue.content.render(destination);
    } else {
      return renderChild(destination, returnValue);
    }
  }
};
function isAstroComponentInstance(obj) {
  return typeof obj === "object" && obj !== null && !!obj[astroComponentInstanceSym];
}

// node_modules/@oslojs/encoding/dist/base32.js
var EncodingPadding;
(function(EncodingPadding3) {
  EncodingPadding3[EncodingPadding3["Include"] = 0] = "Include";
  EncodingPadding3[EncodingPadding3["None"] = 1] = "None";
})(EncodingPadding || (EncodingPadding = {}));
var DecodingPadding;
(function(DecodingPadding3) {
  DecodingPadding3[DecodingPadding3["Required"] = 0] = "Required";
  DecodingPadding3[DecodingPadding3["Ignore"] = 1] = "Ignore";
})(DecodingPadding || (DecodingPadding = {}));

// node_modules/@oslojs/encoding/dist/base64.js
var EncodingPadding2;
(function(EncodingPadding3) {
  EncodingPadding3[EncodingPadding3["Include"] = 0] = "Include";
  EncodingPadding3[EncodingPadding3["None"] = 1] = "None";
})(EncodingPadding2 || (EncodingPadding2 = {}));
var DecodingPadding2;
(function(DecodingPadding3) {
  DecodingPadding3[DecodingPadding3["Required"] = 0] = "Required";
  DecodingPadding3[DecodingPadding3["Ignore"] = 1] = "Ignore";
})(DecodingPadding2 || (DecodingPadding2 = {}));

// node_modules/astro/dist/core/encryption.js
var encoder2 = new TextEncoder();
var decoder2 = new TextDecoder();

// node_modules/astro/dist/runtime/server/render/component.js
var needsHeadRenderingSymbol = Symbol.for("astro.needsHeadRendering");

// node_modules/astro/dist/runtime/server/jsx.js
var hasTriedRenderComponentSymbol = Symbol("hasTriedRenderComponent");

// node_modules/astro/dist/runtime/server/transition.js
var import_cssesc = __toESM(require_cssesc(), 1);
var reEncodeValidChars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_".split("").reduce((v, c) => (v[c.charCodeAt(0)] = c, v), []);
var reEncodeInValidStart = "-0123456789_".split("").reduce((v, c) => (v[c.charCodeAt(0)] = c, v), []);

// node_modules/astro/dist/core/server-islands/endpoint.js
var SERVER_ISLAND_BASE_PREFIX = "_server-islands";

// node_modules/astro/dist/core/routing/match.js
var ROUTE404_RE = /^\/404\/?$/;
var ROUTE500_RE = /^\/500\/?$/;
function isRoute404(route) {
  return ROUTE404_RE.test(route);
}
function isRoute500(route) {
  return ROUTE500_RE.test(route);
}
function isRequestServerIsland(request, base2 = "") {
  const url = new URL(request.url);
  const pathname = base2 === "/" ? url.pathname.slice(base2.length) : url.pathname.slice(base2.length + 1);
  return pathname.startsWith(SERVER_ISLAND_BASE_PREFIX);
}
function requestIs404Or500(request, base2 = "") {
  const url = new URL(request.url);
  const pathname = url.pathname.slice(base2.length);
  return isRoute404(pathname) || isRoute500(pathname);
}

// node_modules/astro/dist/i18n/middleware.js
function createI18nMiddleware(i18n2, base2, trailingSlash2, format2) {
  if (!i18n2) return (_, next) => next();
  const payload = {
    ...i18n2,
    trailingSlash: trailingSlash2,
    base: base2,
    format: format2,
    domains: {}
  };
  const _redirectToDefaultLocale = redirectToDefaultLocale(payload);
  const _noFoundForNonLocaleRoute = notFound(payload);
  const _requestHasLocale = requestHasLocale(payload.locales);
  const _redirectToFallback = redirectToFallback(payload);
  const prefixAlways = (context, response) => {
    const url = context.url;
    if (url.pathname === base2 + "/" || url.pathname === base2) {
      return _redirectToDefaultLocale(context);
    } else if (!_requestHasLocale(context)) {
      return _noFoundForNonLocaleRoute(context, response);
    }
    return void 0;
  };
  const prefixOtherLocales = (context, response) => {
    let pathnameContainsDefaultLocale = false;
    const url = context.url;
    for (const segment of url.pathname.split("/")) {
      if (normalizeTheLocale(segment) === normalizeTheLocale(i18n2.defaultLocale)) {
        pathnameContainsDefaultLocale = true;
        break;
      }
    }
    if (pathnameContainsDefaultLocale) {
      const newLocation = url.pathname.replace(`/${i18n2.defaultLocale}`, "");
      response.headers.set("Location", newLocation);
      return _noFoundForNonLocaleRoute(context);
    }
    return void 0;
  };
  return async (context, next) => {
    const response = await next();
    const type = response.headers.get(ROUTE_TYPE_HEADER);
    const isReroute = response.headers.get(REROUTE_DIRECTIVE_HEADER);
    if (isReroute === "no" && typeof i18n2.fallback === "undefined") {
      return response;
    }
    if (type !== "page" && type !== "fallback") {
      return response;
    }
    if (requestIs404Or500(context.request, base2)) {
      return response;
    }
    if (isRequestServerIsland(context.request, base2)) {
      return response;
    }
    const { currentLocale } = context;
    switch (i18n2.strategy) {
      // NOTE: theoretically, we should never hit this code path
      case "manual": {
        return response;
      }
      case "domains-prefix-other-locales": {
        if (localeHasntDomain(i18n2, currentLocale)) {
          const result = prefixOtherLocales(context, response);
          if (result) {
            return result;
          }
        }
        break;
      }
      case "pathname-prefix-other-locales": {
        const result = prefixOtherLocales(context, response);
        if (result) {
          return result;
        }
        break;
      }
      case "domains-prefix-always-no-redirect": {
        if (localeHasntDomain(i18n2, currentLocale)) {
          const result = _noFoundForNonLocaleRoute(context, response);
          if (result) {
            return result;
          }
        }
        break;
      }
      case "pathname-prefix-always-no-redirect": {
        const result = _noFoundForNonLocaleRoute(context, response);
        if (result) {
          return result;
        }
        break;
      }
      case "pathname-prefix-always": {
        const result = prefixAlways(context, response);
        if (result) {
          return result;
        }
        break;
      }
      case "domains-prefix-always": {
        if (localeHasntDomain(i18n2, currentLocale)) {
          const result = prefixAlways(context, response);
          if (result) {
            return result;
          }
        }
        break;
      }
    }
    return _redirectToFallback(context, response);
  };
}
function localeHasntDomain(i18n2, currentLocale) {
  for (const domainLocale of Object.values(i18n2.domainLookupTable)) {
    if (domainLocale === currentLocale) {
      return false;
    }
  }
  return true;
}

// node_modules/astro/dist/i18n/index.js
function requestHasLocale(locales2) {
  return function(context) {
    return pathHasLocale(context.url.pathname, locales2);
  };
}
function pathHasLocale(path, locales2) {
  const segments = path.split("/");
  for (const segment of segments) {
    for (const locale of locales2) {
      if (typeof locale === "string") {
        if (normalizeTheLocale(segment) === normalizeTheLocale(locale)) {
          return true;
        }
      } else if (segment === locale.path) {
        return true;
      }
    }
  }
  return false;
}
function getLocaleRelativeUrl({
  locale,
  base: base2,
  locales: _locales,
  trailingSlash: trailingSlash2,
  format: format2,
  path,
  prependWith,
  normalizeLocale = true,
  strategy: strategy2 = "pathname-prefix-other-locales",
  defaultLocale: defaultLocale2
}) {
  const codeToUse = peekCodePathToUse(_locales, locale);
  if (!codeToUse) {
    throw new AstroError({
      ...MissingLocale,
      message: MissingLocale.message(locale)
    });
  }
  const pathsToJoin = [base2, prependWith];
  const normalizedLocale = normalizeLocale ? normalizeTheLocale(codeToUse) : codeToUse;
  if (strategy2 === "pathname-prefix-always" || strategy2 === "pathname-prefix-always-no-redirect" || strategy2 === "domains-prefix-always" || strategy2 === "domains-prefix-always-no-redirect") {
    pathsToJoin.push(normalizedLocale);
  } else if (locale !== defaultLocale2) {
    pathsToJoin.push(normalizedLocale);
  }
  pathsToJoin.push(path);
  let relativePath;
  if (shouldAppendForwardSlash(trailingSlash2, format2)) {
    relativePath = appendForwardSlash(joinPaths(...pathsToJoin));
  } else {
    relativePath = joinPaths(...pathsToJoin);
  }
  if (relativePath === "") {
    return "/";
  }
  return relativePath;
}
function getLocaleAbsoluteUrl({ site: site2, isBuild: isBuild2, ...rest }) {
  const localeUrl = getLocaleRelativeUrl(rest);
  const { domains: domains2, locale } = rest;
  let url;
  if (isBuild2 && domains2 && domains2[locale]) {
    const base2 = domains2[locale];
    url = joinPaths(base2, localeUrl.replace(`/${rest.locale}`, ""));
  } else {
    if (localeUrl === "/") {
      url = site2 || "/";
    } else if (site2) {
      url = joinPaths(site2, localeUrl);
    } else {
      url = localeUrl;
    }
  }
  if (shouldAppendForwardSlash(rest.trailingSlash, rest.format)) {
    return appendForwardSlash(url);
  } else {
    return url;
  }
}
function getLocaleRelativeUrlList({
  locales: _locales,
  ...rest
}) {
  const locales2 = toPaths(_locales);
  return locales2.map((locale) => {
    return getLocaleRelativeUrl({ ...rest, locales: locales2, locale });
  });
}
function getLocaleAbsoluteUrlList(params) {
  const locales2 = toCodes(params.locales);
  return locales2.map((currentLocale) => {
    return getLocaleAbsoluteUrl({ ...params, locale: currentLocale });
  });
}
function getPathByLocale(locale, locales2) {
  for (const loopLocale of locales2) {
    if (typeof loopLocale === "string") {
      if (loopLocale === locale) {
        return loopLocale;
      }
    } else {
      for (const code of loopLocale.codes) {
        if (code === locale) {
          return loopLocale.path;
        }
      }
    }
  }
  throw new AstroError(i18nNoLocaleFoundInPath);
}
function getLocaleByPath(path, locales2) {
  for (const locale of locales2) {
    if (typeof locale !== "string") {
      if (locale.path === path) {
        const code = locale.codes.at(0);
        if (code === void 0) throw new AstroError(i18nNoLocaleFoundInPath);
        return code;
      }
    } else if (locale === path) {
      return locale;
    }
  }
  throw new AstroError(i18nNoLocaleFoundInPath);
}
function normalizeTheLocale(locale) {
  return locale.replaceAll("_", "-").toLowerCase();
}
function toCodes(locales2) {
  return locales2.map((loopLocale) => {
    if (typeof loopLocale === "string") {
      return loopLocale;
    } else {
      return loopLocale.codes[0];
    }
  });
}
function toPaths(locales2) {
  return locales2.map((loopLocale) => {
    if (typeof loopLocale === "string") {
      return loopLocale;
    } else {
      return loopLocale.path;
    }
  });
}
function peekCodePathToUse(locales2, locale) {
  for (const loopLocale of locales2) {
    if (typeof loopLocale === "string") {
      if (loopLocale === locale) {
        return loopLocale;
      }
    } else {
      for (const code of loopLocale.codes) {
        if (code === locale) {
          return loopLocale.path;
        }
      }
    }
  }
  return void 0;
}
function redirectToDefaultLocale({
  trailingSlash: trailingSlash2,
  format: format2,
  base: base2,
  defaultLocale: defaultLocale2
}) {
  return function(context, statusCode) {
    if (shouldAppendForwardSlash(trailingSlash2, format2)) {
      return context.redirect(`${appendForwardSlash(joinPaths(base2, defaultLocale2))}`, statusCode);
    } else {
      return context.redirect(`${joinPaths(base2, defaultLocale2)}`, statusCode);
    }
  };
}
function notFound({ base: base2, locales: locales2, fallback: fallback2 }) {
  return function(context, response) {
    if ((response == null ? void 0 : response.headers.get(REROUTE_DIRECTIVE_HEADER)) === "no" && typeof fallback2 === "undefined") {
      return response;
    }
    const url = context.url;
    const isRoot = url.pathname === base2 + "/" || url.pathname === base2;
    if (!(isRoot || pathHasLocale(url.pathname, locales2))) {
      if (response) {
        response.headers.set(REROUTE_DIRECTIVE_HEADER, "no");
        return new Response(response.body, {
          status: 404,
          headers: response.headers
        });
      } else {
        return new Response(null, {
          status: 404,
          headers: {
            [REROUTE_DIRECTIVE_HEADER]: "no"
          }
        });
      }
    }
    return void 0;
  };
}
function redirectToFallback({
  fallback: fallback2,
  locales: locales2,
  defaultLocale: defaultLocale2,
  strategy: strategy2,
  base: base2,
  fallbackType: fallbackType2
}) {
  return async function(context, response) {
    if (response.status >= 300 && fallback2) {
      const fallbackKeys = fallback2 ? Object.keys(fallback2) : [];
      const segments = context.url.pathname.split("/");
      const urlLocale = segments.find((segment) => {
        for (const locale of locales2) {
          if (typeof locale === "string") {
            if (locale === segment) {
              return true;
            }
          } else if (locale.path === segment) {
            return true;
          }
        }
        return false;
      });
      if (urlLocale && fallbackKeys.includes(urlLocale)) {
        const fallbackLocale = fallback2[urlLocale];
        const pathFallbackLocale = getPathByLocale(fallbackLocale, locales2);
        let newPathname;
        if (pathFallbackLocale === defaultLocale2 && strategy2 === "pathname-prefix-other-locales") {
          if (context.url.pathname.includes(`${base2}`)) {
            newPathname = context.url.pathname.replace(`/${urlLocale}`, ``);
          } else {
            newPathname = context.url.pathname.replace(`/${urlLocale}`, `/`);
          }
        } else {
          newPathname = context.url.pathname.replace(`/${urlLocale}`, `/${pathFallbackLocale}`);
        }
        if (fallbackType2 === "rewrite") {
          return await context.rewrite(newPathname + context.url.search);
        } else {
          return context.redirect(newPathname + context.url.search);
        }
      }
    }
    return response;
  };
}
function createMiddleware(i18nManifest, base2, trailingSlash2, format2) {
  return createI18nMiddleware(i18nManifest, base2, trailingSlash2, format2);
}

// node_modules/astro/dist/i18n/utils.js
function toRoutingStrategy(routing2, domains2) {
  let strategy2;
  const hasDomains = domains2 ? Object.keys(domains2).length > 0 : false;
  if (routing2 === "manual") {
    strategy2 = "manual";
  } else {
    if (!hasDomains) {
      if ((routing2 == null ? void 0 : routing2.prefixDefaultLocale) === true) {
        if (routing2.redirectToDefaultLocale) {
          strategy2 = "pathname-prefix-always";
        } else {
          strategy2 = "pathname-prefix-always-no-redirect";
        }
      } else {
        strategy2 = "pathname-prefix-other-locales";
      }
    } else {
      if ((routing2 == null ? void 0 : routing2.prefixDefaultLocale) === true) {
        if (routing2.redirectToDefaultLocale) {
          strategy2 = "domains-prefix-always";
        } else {
          strategy2 = "domains-prefix-always-no-redirect";
        }
      } else {
        strategy2 = "domains-prefix-other-locales";
      }
    }
  }
  return strategy2;
}
function toFallbackType(routing2) {
  if (routing2 === "manual") {
    return "rewrite";
  }
  return routing2.fallbackType;
}

// node_modules/astro/dist/virtual-modules/i18n.js
var { trailingSlash, format, site, i18n, isBuild } = (
  // @ts-expect-error
  __ASTRO_INTERNAL_I18N_CONFIG__
);
var { defaultLocale, locales, domains, fallback, routing } = i18n;
var base = import.meta.env.BASE_URL;
var strategy = toRoutingStrategy(routing, domains);
var fallbackType = toFallbackType(routing);
var noop2 = (method) => function() {
  throw new AstroError({
    ...IncorrectStrategyForI18n,
    message: IncorrectStrategyForI18n.message(method)
  });
};
var getRelativeLocaleUrl = (locale, path, options) => getLocaleRelativeUrl({
  locale,
  path,
  base,
  trailingSlash,
  format,
  defaultLocale,
  locales,
  strategy,
  domains,
  ...options
});
var getAbsoluteLocaleUrl = (locale, path, options) => getLocaleAbsoluteUrl({
  locale,
  path,
  base,
  trailingSlash,
  format,
  site,
  defaultLocale,
  locales,
  strategy,
  domains,
  isBuild,
  ...options
});
var getRelativeLocaleUrlList = (path, options) => getLocaleRelativeUrlList({
  base,
  path,
  trailingSlash,
  format,
  defaultLocale,
  locales,
  strategy,
  domains,
  ...options
});
var getAbsoluteLocaleUrlList = (path, options) => getLocaleAbsoluteUrlList({
  site,
  base,
  path,
  trailingSlash,
  format,
  defaultLocale,
  locales,
  strategy,
  domains,
  isBuild,
  ...options
});
var getPathByLocale2 = (locale) => getPathByLocale(locale, locales);
var getLocaleByPath2 = (path) => getLocaleByPath(path, locales);
var pathHasLocale2 = (path) => pathHasLocale(path, locales);
var redirectToDefaultLocale2;
if ((i18n == null ? void 0 : i18n.routing) === "manual") {
  redirectToDefaultLocale2 = redirectToDefaultLocale({
    base,
    trailingSlash,
    format,
    defaultLocale,
    locales,
    strategy,
    domains,
    fallback,
    fallbackType
  });
} else {
  redirectToDefaultLocale2 = noop2("redirectToDefaultLocale");
}
var notFound2;
if ((i18n == null ? void 0 : i18n.routing) === "manual") {
  notFound2 = notFound({
    base,
    trailingSlash,
    format,
    defaultLocale,
    locales,
    strategy,
    domains,
    fallback,
    fallbackType
  });
} else {
  notFound2 = noop2("notFound");
}
var requestHasLocale2;
if ((i18n == null ? void 0 : i18n.routing) === "manual") {
  requestHasLocale2 = requestHasLocale(locales);
} else {
  requestHasLocale2 = noop2("requestHasLocale");
}
var redirectToFallback2;
if ((i18n == null ? void 0 : i18n.routing) === "manual") {
  redirectToFallback2 = redirectToFallback({
    base,
    trailingSlash,
    format,
    defaultLocale,
    locales,
    strategy,
    domains,
    fallback,
    fallbackType
  });
} else {
  redirectToFallback2 = noop2("useFallback");
}
var middleware;
if ((i18n == null ? void 0 : i18n.routing) === "manual") {
  middleware = (customOptions) => {
    strategy = toRoutingStrategy(customOptions, {});
    fallbackType = toFallbackType(customOptions);
    const manifest = {
      ...i18n,
      strategy,
      domainLookupTable: {},
      fallbackType,
      fallback: i18n.fallback
    };
    return createMiddleware(manifest, base, trailingSlash, format);
  };
} else {
  middleware = noop2("middleware");
}
export {
  getAbsoluteLocaleUrl,
  getAbsoluteLocaleUrlList,
  getLocaleByPath2 as getLocaleByPath,
  getPathByLocale2 as getPathByLocale,
  getRelativeLocaleUrl,
  getRelativeLocaleUrlList,
  middleware,
  normalizeTheLocale,
  notFound2 as notFound,
  pathHasLocale2 as pathHasLocale,
  redirectToDefaultLocale2 as redirectToDefaultLocale,
  redirectToFallback2 as redirectToFallback,
  requestHasLocale2 as requestHasLocale,
  toCodes,
  toPaths
};
/*! Bundled license information:

astro/dist/runtime/server/shorthash.js:
  (**
   * shortdash - https://github.com/bibig/node-shorthash
   *
   * @license
   *
   * (The MIT License)
   *
   * Copyright (c) 2013 Bibig <bibig@me.com>
   *
   * Permission is hereby granted, free of charge, to any person
   * obtaining a copy of this software and associated documentation
   * files (the "Software"), to deal in the Software without
   * restriction, including without limitation the rights to use,
   * copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the
   * Software is furnished to do so, subject to the following
   * conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
   * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
   * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
   * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   * OTHER DEALINGS IN THE SOFTWARE.
   *)
*/
//# sourceMappingURL=astro_i18n.js.map
